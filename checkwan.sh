#!/bin/sh

. /lib/functions.sh
. /lib/functions/network.sh


__cwecho() {
    if [ -z "$debug" -o "$debug" == "0" ]; then
        $* > /dev/null 2>&1
    else
        $*
    fi
}

__cwlog() {
    #echo "$1"
    logger ${debug:+-s} -p 5 -t checkwan "$1"
}

__config_foreach_prio() {
    local section="$1"; shift
    local option="$1"; shift
    local function="$1"; shift
    local val
    local i=0
    
    while :; do
        let "i++"
        config_get val "${section}" "${option}_${i}"
        if [ -z "$val" ]; then
            break
        fi
        
        if [ "$val" != "disable" ]; then
            eval "$function \"$val\""
        fi
    done
}

query_config() {
    case $1 in
    ifname)     echo $wan_if_map        | grep -o "\<$2\>\[\w*.*\]" | awk -F "[" '{print $2}' | awk -F "]" '{print $1}';; 
    ipaddr)     echo $wan_ip_map        | grep -o "\<$2\>\[\w*.*\]" | awk -F "[" '{print $2}' | awk -F "]" '{print $1}';;
    gateway)    echo $wan_gw_map        | grep -o "\<$2\>\[\w*.*\]" | awk -F "[" '{print $2}' | awk -F "]" '{print $1}';;
    wanid)      echo $wan_id_map        | grep -o "\<$2\>\[\w*.*\]" | awk -F "[" '{print $2}' | awk -F "]" '{print $1}';;
    failchk)    echo $wan_fail_map      | grep -o "\<$2\>\[\w*.*\]" | awk -F "[" '{print $2}' | awk -F "]" '{print $1}';;
    current)    echo $wan_current_map   | grep -o "\<$2\>\[\w*.*\]" | awk -F "[" '{print $2}' | awk -F "]" '{print $1}';;
    group)      echo $wan_id_map        | grep -o "\w*\[$2\]" | awk -F "[" '{print $1}';;
    esac
}

update_cache() {
    #lock /var/lock/checkwan.lock
    
    if [ ! -d /tmp/.checkwan ]; then
    mkdir /tmp/.checkwan > /dev/null 2>&1
    fi
    
    rm /tmp/.checkwan/cache > /dev/null 2>&1
    touch /tmp/.checkwan/cache
    
    echo "# Automatically Generated by Check-WAN Agent Script. Do not modify or remove. #" > /tmp/.checkwan/cache
    echo "wan_id_map=\"$wan_id_map\"" >> /tmp/.checkwan/cache
    echo "wan_if_map=\"$wan_if_map\"" >> /tmp/.checkwan/cache
    echo "wan_ip_map=\"$wan_ip_map\"" >> /tmp/.checkwan/cache
    echo "wan_gw_map=\"$wan_gw_map\"" >> /tmp/.checkwan/cache
    echo "wan_fail_map=\"$wan_fail_map\"" >> /tmp/.checkwan/cache
    echo "wan_current_map=\"$wan_current_map\"" >> /tmp/.checkwan/cache
    
    #lock -u /var/lock/checkwan.lock
}

acquire_wan_data() {
    local interface="$1"
    local check_old_map
    local old_ifname
    local old_wanid
    local old_ipaddr
    local old_gateway
    
    local ifname ipaddr gateway
    network_get_device ifname ${interface} || ifname=x
    network_get_ipaddr ipaddr ${interface} || ipaddr=x
    network_get_gateway gateway ${interface} || gateway=x
    
    check_old_map=$(echo $wan_id_map 2>&1 | grep -o "\<$interface\>\[")
    if [ -z "$check_old_map" ]; then
        wancount=$(($wancount + 1))
        wan_if_map="$wan_if_map${interface}[${ifname}]"
        wan_id_map="$wan_id_map${interface}[${wancount}]"
        wan_ip_map="$wan_ip_map${interface}[${ipaddr}]"
        wan_gw_map="$wan_gw_map${interface}[${gateway}]"
    else
        # only network status changed, update
        old_ipaddr=$(query_config ipaddr $interface)
        old_gateway=$(query_config gateway $interface)
        old_ifname=$(query_config ifname $interface)
        
        wan_if_map=$(echo $wan_if_map | sed -e "s/\<${interface}\>\[${old_ifname}\]/$interface\[${ifname}\]/g")
        wan_ip_map=$(echo $wan_ip_map | sed -e "s/\<${interface}\>\[${old_ipaddr}\]/$interface\[${ipaddr}\]/g")
        wan_gw_map=$(echo $wan_gw_map | sed -e "s/\<${interface}\>\[${old_gateway}\]/$interface\[${gateway}\]/g")
    fi
}


checkwan_kill() {
    local pids=$(ps 2>&1 | grep 'checkwan agent' | grep -v grep | grep -v $$ | awk '{print $1}')
    [ -n "$pids" ] && kill $pids > /dev/null 2>&1
    sleep 2
}

# no delete route default
flush() {
    echo "## Flushing IP Rules and Routes ##"
    
    local i=0
    while [ $((i++)) -lt $wancount ]; do
        ip rule del prio $(($i * 10)) > /dev/null 2>&1
        ip rule del prio $(($i * 10 + 1)) > /dev/null 2>&1
        ip route flush table $(($i + 170)) > /dev/null 2>&1
    done
}


refresh_iprules() {
    local group
    local gateway
    local ipaddr
    local ifname
    local TABLE
    
    echo "## Refreshing IP Rules ##"
    
    local i=0
    while [ $((i++)) -lt $wancount ]; do
        group=$(query_config group $i)
        gateway=$(query_config gateway $group)
        ipaddr=$(query_config ipaddr $group)
        ifname=$(query_config ifname $group)
        
        ip rule del prio $(($i * 10)) > /dev/null 2>&1
        ip rule del prio $(($i * 10 + 1)) > /dev/null 2>&1
        
        if [ "$gateway" != "x" -a "$ipaddr" != "x" -a "$ifname" != "x" ]; then
            TABLE=$(($i + 170))
            ip rule add iif $ifname table $TABLE prio $(($i * 10))
            ip rule add oif $ifname table $TABLE prio $(($i * 10 + 1))
        fi
    done
}

refresh_routes() {
    local gateway
    local group
    local ifname
    local ipaddr
    local TABLE
    
    echo "## Refreshing Routing Tables ##"
    
    local i=0
    while [ $((i++)) -lt $wancount ]; do
        group=$(query_config group $i)
        gateway=$(query_config gateway $group)
        ifname=$(query_config ifname $group)
        ipaddr=$(query_config ipaddr $group)
        
        TABLE=$(($i + 170))
        ip route flush table $TABLE > /dev/null 2>&1
        
        ip route | grep -Ev ^default | while read ROUTE; do
            ip route add table $TABLE to $ROUTE
        done
        
        if [ "$gateway" != "x" -a "$ipaddr" != "x" -a "$ifname" != "x" ]; then
            ip route add default via $gateway table $TABLE
        fi
    done
    
    ip route flush cache
}

refresh_iprules_and_routes() {
    refresh_iprules
    refresh_routes
}

failover() {
    local group=$2
    local chk=$3
    local old_failchk=$(query_config failchk $group)
    
    add() {
        wan_fail_map=$(echo $wan_fail_map | sed -e "s/\<${1}\>\[${old_failchk}\]//g")
        wan_fail_map="$wan_fail_map${1}[${2}]"
        old_current=$(query_config current ${1})
        [ -z "$old_current" ] || wan_current_map=$(echo $wan_current_map | sed -e "s/\<${1}\>\[${old_current}\]//g")
        update_cache
    }
    
    del() {
        wan_fail_map=$(echo $wan_fail_map | sed -e "s/\<${1}\>\[${old_failchk}\]//g")
        wan_current_map="${1}[${2}]"
        update_cache
    }
    
    case $1 in
        add) add $group $chk;;
        del) del $group $chk;;
    esac
}

monitor_wan() {
    local wanid=$1
    local priority_last=$(($wanid - 1))
    local need_check=0
    local last_need_check=0
    local check_test
    local fail_count=0
    local recovery_count=0
    
    local timeout=$(uci_get_state checkwan config timeout)
    local icmp_hosts=$(uci_get_state checkwan config icmp_hosts)
    local icmp_count=$(uci_get_state checkwan config icmp_count '1')
    local health_interval=$(uci_get_state checkwan config health_interval)
    local fail_retries=$(uci_get_state checkwan config health_fail_retries)
    local recovery_retries=$(uci_get_state checkwan config health_recovery_retries)
    
    while :; do
        sleep $health_interval
        . /tmp/.checkwan/cache
    
        local group=$(query_config group $wanid)
        local ifname_cur=$(query_config ifname $group)
        local ipaddr_cur=$(query_config ipaddr $group)
        local gateway_cur=$(query_config gateway $group)
    
        local pre_group=$(query_config group $priority_last)
        local pre_failchk=$(query_config failchk $pre_group)
        
        network_get_device  ifname  ${group} || ifname=x
        network_get_ipaddr  ipaddr  ${group} || ipaddr=x
        network_get_gateway gateway ${group} || gateway=x
        
        # if network status changed, update cache and refresh
        # network_get_xxx cannot return right value,
        # so luci-app-checkwan will add_list ucitrack.@network[-1].affects="checkwan"
        if [ "$ifname_cur" != "$ifname" -o "$ipaddr_cur" != "$ipaddr" -o "$gateway_cur" != "$gateway" ]; then
            __config_foreach_prio config priority acquire_wan_data
            update_cache
            refresh_iprules_and_routes
            continue
        fi
        
        last_need_check=$need_check
        
        if [ $priority_last -lt 1 ]; then # if this is priority level 1 , this network need check
            need_check=1
            #echo "$group priority level 1, need check"
        elif [ ! -z "$pre_failchk" ]; then # if last priority level check failed, this network need check
            need_check=1
            #echo "$group pre_group=>$pre_group check failed, need check"
        else
            need_check=0
            continue
        fi
        
        if [ "$need_check" != "$last_need_check" ]; then
            fail_count=0
            recovery_count=0
        fi
        
        # get right icmp_hosts
        if [ "$icmp_hosts" == "gateway" -o -z "$icmp_hosts" ]; then
            icmp_hosts_acquire=$gateway
        elif [ "$icmp_hosts" == "dns" ]; then
            network_get_dnsserver icmp_hosts_acquire $group
        else
            icmp_hosts_acquire=$icmp_hosts
        fi
        
        icmp_hosts=$(echo $icmp_hosts_acquire | sed -e "s/\,/ /g" | sed -e "s/ /\n/g")
        ping_test() {
            # if this has multi hosts, it will pass even one of them passed
            echo "$icmp_hosts" | while read icmp_test_hosts; do
                ping -c "$icmp_count" -W $timeout -I $ifname $icmp_test_hosts 2>&1 | grep -o "round-trip"
            done
        }
        
        # if network status is x , check failed
        if [ "$ifname" != "x" -a "$ipaddr" != "x" -a "$gateway" != "x" ]; then
            check_test=$(ping_test)
        else
            check_test=""
        fi
        
        if [ -z "$check_test" ]; then
            fail_count=$(($fail_count + 1))
            recovery_count=0
        else
            recovery_count=$(($recovery_count + 1))
            fail_count=0
        fi
        
        if [ $fail_count -ge $fail_retries ]; then
            if [ $fail_count -ge 999 ]; then
                fail_count=999
            fi
            
            failover add $group $fail_count
        fi
        
        if [ $recovery_count -ge $recovery_retries ]; then
            if [ "$recovery_count" -eq "$recovery_retries" -a "$ifname" != "x" -a "$ipaddr" != "x" -a "$gateway" != "x" ]; then
                # change to current interface, set default route to current gateway
                __cwlog "$group was connected and now online"
                route del default
                route add default gw $gateway
                env -i ACTION=ifupdate INTERFACE=$group DEVICE=$ifname /sbin/hotplug-call iface
            fi
            
            if [ $recovery_count -ge 999 ]; then
                recovery_count=999
            fi
            
            failover del $group $recovery_count
        fi
    done
}

main_init() {
    echo "## Main Initialization ##"
    
    mkdir /tmp/.checkwan > /dev/null 2>&1
    
    checkwan_kill
    flush
    
    refresh_iprules_and_routes
    
    __cwlog "Successfully Initialized on $(date -R)"
    local i=0
    while [ $((i++)) -lt $wancount ]; do
        monitor_wan $i &
        sleep 1
    done
}

stop() {
    checkwan_kill
    flush
    ip route flush cache
    
    rm -rf /tmp/.checkwan >&- 2>&-
    echo "## Check-WAN stoped ##"
    
    if [ "$1" == "restart" ]; then
        echo "## Restarting Check-WAN. ##"
        __cwlog "Reinitializing Check-WAN Configuration."
        /etc/init.d/checkwan start >&- 2>&-
    fi
    
    exit
}


wancount=0
config_load "checkwan"

config_get debug config debug

# use to calculat wancount
__config_foreach_prio config priority acquire_wan_data
update_cache


config_get_bool enabled config enabled '0'
[ "$enabled" -gt 0 ] || {
    __cwecho stop
    exit
}


case $1 in
    agent) __cwecho main_init;;
    stop) __cwecho stop;;
    restart) __cwecho stop restart;;
esac

